#!/usr/bin/env python
'''
$Id: tzfile.py,v 1.3 2003/05/05 13:51:10 zenzen Exp $
'''

__rcs_id__  = '$Id: tzfile.py,v 1.3 2003/05/05 13:51:10 zenzen Exp $'
__version__ = '$Revision: 1.3 $'[11:-2]

from struct import unpack,calcsize
from cStringIO import StringIO
from time import gmtime,asctime
from pprint import pprint

from datetime import datetime,timedelta

class TZFile:
    ''' Wrapper around a tzfile(5) format file as generated by zic(1) '''
    def __init__(self,filename):
        self.tzload(filename)

    def tzload(self,filename):
        self.filename = filename
        inf = open(filename,'rb')

        # See elsie.nci.nih.gov/src/tzfile.5 for details of the file format
        
        head_fmt = '>4s16x6l'
        head_size = calcsize(head_fmt)

        (magic,ttisgmtcnt,ttisstdcnt,leapcnt,timecnt,typecnt,charcnt) = \
            unpack(head_fmt,inf.read(head_size))

        # Make sure it is a tzinfo(5) file
        assert magic == 'TZif'

        # Our transition times
        transitions_fmt = '>%dl' % (timecnt)
        transitions_size = calcsize(transitions_fmt)
        transitions = unpack(transitions_fmt,inf.read(transitions_size))

        # Our indexes into the local time structures
        lindexes = unpack('%dB' % (timecnt),inf.read(timecnt))

        # Our ttinfo structures, detailing gmtoffset, isdst and abbriv index
        ttinfo_fmt = '>lBB'
        ttinfo_size = calcsize(ttinfo_fmt)
        ttinfo = [ 
            unpack(ttinfo_fmt,inf.read(ttinfo_size)) for i in xrange(0,typecnt)
            ]

        # Our timezone abbreviations. ttinfo records reference these as an 
        # index into this long sequence of characters, so generate a mapping
        # to map char position -> tzname for later
        tznames_raw = inf.read(charcnt)
        assert tznames_raw[-1] == '\0'
        tznames_list = tznames_raw.split('\0')[:-1]
        i = 0
        tznames = {}
        for n in tznames_list:
            tznames[i] = n
            i += len(n) + 1

        self.transitions = [ ( 
            transitions[i],         # epoch time of transition
            ttinfo[lindexes[i]][0], # utc offset in seconds
            bool(ttinfo[lindexes[i]][1]), # is DST
            tznames[ttinfo[lindexes[i]][2]] # timezone abbreviation
            ) for i in xrange(0,len(transitions)) ]

        # build transitions_mapping
        m = {}
        for t in self.transitions:
            dt = datetime.utcfromtimestamp(t[0])
            s = (dt, (timedelta(seconds=t[1]),t[2],t[3]))
            if not m.has_key(dt.year):
                m[dt.year] = [s]
            else:
                m[dt.year].append(s)
        self.transitions_mapping = m

    def __repr__(self):
        return "TZFile(%s)" % repr(self.filename)

    def asPython(self,indent=4):
        out = StringIO()
        print >> out,'['
        indent -= 1
        for t in self.transitions:
            nice = asctime(gmtime(t[0])) + ' UTC'
            print >> out, ' '*indent, 
            print >> out, '(%11d,' % (t[0]),
            print >> out, '%6d,' % (t[1]),
            print >> out, '%-6s' % (repr(t[2]) + ','),
            print >> out, '%-10s' % (repr(t[3]) + '),'),
            print >> out, '#',nice
        print >> out, ' '*indent, ']'
        return out.getvalue()

if __name__ == '__main__':
    import os.path
    base = os.path.join('elsie.nci.nih.gov','build','etc','zoneinfo')
    tz = TZFile(os.path.join(base,'Australia','Melbourne'))
    tz = TZFile(os.path.join(base,'US','Eastern'))
    print tz.asPython(4)
    #print tz.transitions_mapping
