#!/usr/bin/env python
'''
$Id: tzfile.py,v 1.7 2004/06/02 23:08:53 zenzen Exp $
'''

__rcs_id__  = '$Id: tzfile.py,v 1.7 2004/06/02 23:08:53 zenzen Exp $'
__version__ = '$Revision: 1.7 $'[11:-2]

from struct import unpack,calcsize
from cStringIO import StringIO
from time import gmtime,asctime
from pprint import pprint

from datetime import datetime, timedelta

class TZFile:
    ''' Wrapper around a tzfile(5) format file as generated by zic(1) '''
    def __init__(self,filename):
        self.tzload(filename)

    def tzload(self,filename):
        self.filename = filename
        inf = open(filename,'rb')

        # See elsie.nci.nih.gov/src/tzfile.5 for details of the file format
        
        head_fmt = '>4s16x6l'
        head_size = calcsize(head_fmt)

        (magic,ttisgmtcnt,ttisstdcnt,leapcnt,timecnt,typecnt,charcnt) = \
            unpack(head_fmt,inf.read(head_size))

        # Make sure it is a tzinfo(5) file
        assert magic == 'TZif'

        # Our transition times
        transitions_fmt = '>%dl' % (timecnt)
        transitions_size = calcsize(transitions_fmt)
        transitions = unpack(transitions_fmt,inf.read(transitions_size))

        # Our indexes into the local time structures
        lindexes = unpack('%dB' % (timecnt),inf.read(timecnt))

        # Our ttinfo structures, detailing gmtoffset, isdst and abbriv index
        ttinfo_fmt = '>lBB'
        ttinfo_size = calcsize(ttinfo_fmt)
        ttinfo = [
            unpack(ttinfo_fmt,inf.read(ttinfo_size)) for i in xrange(0,typecnt)
            ]

        # Our timezone abbreviations. ttinfo records reference these as an 
        # index into this long sequence of characters, so generate a mapping
        # to map char position -> tzname for later
        tznames_raw = inf.read(charcnt)
        assert tznames_raw[-1] == '\0'
        tznames_list = tznames_raw.split('\0')[:-1]
        #i = 0
        #tznames = {}
        #for n in tznames_list:
        #    tznames[i] = n
        #    i += len(n) + 1
        tznames = []
        for n in tznames_list:
            for i in range(0, len(n)):
                tznames.append(n[i:])
            tznames.append(None) # NULL terminator

        # Make ttinfo more informative
        ttinfo = [
            (timedelta(seconds=utcoffset),bool(is_dst),tznames[tzname_index])
                for utcoffset,is_dst,tzname_index in ttinfo
            ]

        assert len(lindexes) == len(transitions)
        self.transitions = [ (
            datetime.utcfromtimestamp(transitions[i]), # UTC time of transition
            ttinfo[lindexes[i]][0], # utc offset
            ttinfo[lindexes[i]][1], # is DST
            ttinfo[lindexes[i]][2], # timezone abbreviation
            ) for i in range(0,len(transitions)) ]

        # Early dates use the first standard time ttinfo
        i = 0
        while ttinfo[i][1]:
            i += 1
        self.transitions.insert(
                0, (datetime.min, ttinfo[i][0], ttinfo[i][1], ttinfo[i][2])
                )

        self.ttinfo = ttinfo

    def __repr__(self):
        return "TZFile(%s)" % repr(self.filename)

if __name__ == '__main__':
    import os.path
    base = os.path.join('elsie.nci.nih.gov','build','etc','zoneinfo')
    tz = TZFile(os.path.join(base,'Australia','Melbourne'))
    tz = TZFile(os.path.join(base,'US','Eastern'))
    pprint(tz.transitions)
    #print tz.asPython(4)
    #print tz.transitions_mapping
